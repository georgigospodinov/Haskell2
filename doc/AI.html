<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>AI</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_AI.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">AI</p></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:GameTree">GameTree</a> = <a href="#v:GameTree">GameTree</a> {<ul class="subs"><li><a href="#v:game_board">game_board</a> :: <a href="Board.html#t:Board">Board</a></li><li><a href="#v:game_turn">game_turn</a> :: <a href="Board.html#t:Col">Col</a></li><li><a href="#v:next_moves">next_moves</a> :: [(<a href="Board.html#t:Position">Position</a>, <a href="AI.html#t:GameTree">GameTree</a>)]</li></ul>}</li><li class="src short"><a href="#v:buildTree">buildTree</a> :: (<a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Col">Col</a> -&gt; [<a href="Board.html#t:Position">Position</a>]) -&gt; <a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Col">Col</a> -&gt; <a href="AI.html#t:GameTree">GameTree</a></li><li class="src short"><a href="#v:getBestMove">getBestMove</a> :: Int -&gt; <a href="AI.html#t:GameTree">GameTree</a> -&gt; <a href="Board.html#t:Col">Col</a> -&gt; <a href="Board.html#t:Position">Position</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Selector">Selector</a> = [(Int, <a href="Board.html#t:Position">Position</a>)] -&gt; (Int, <a href="Board.html#t:Position">Position</a>)</li><li class="src short"><a href="#v:recurse">recurse</a> :: Int -&gt; <a href="AI.html#t:Selector">Selector</a> -&gt; <a href="AI.html#t:GameTree">GameTree</a> -&gt; <a href="Board.html#t:Col">Col</a> -&gt; (Int, <a href="Board.html#t:Position">Position</a>)</li><li class="src short"><a href="#v:switchSelector">switchSelector</a> :: <a href="AI.html#t:Selector">Selector</a> -&gt; <a href="AI.html#t:Selector">Selector</a></li><li class="src short"><a href="#v:best">best</a> :: <a href="AI.html#t:Selector">Selector</a></li><li class="src short"><a href="#v:worst">worst</a> :: <a href="AI.html#t:Selector">Selector</a></li><li class="src short"><a href="#v:greater">greater</a> :: (Int, <a href="Board.html#t:Position">Position</a>) -&gt; (Int, <a href="Board.html#t:Position">Position</a>) -&gt; (Int, <a href="Board.html#t:Position">Position</a>)</li><li class="src short"><a href="#v:lesser">lesser</a> :: (Int, <a href="Board.html#t:Position">Position</a>) -&gt; (Int, <a href="Board.html#t:Position">Position</a>) -&gt; (Int, <a href="Board.html#t:Position">Position</a>)</li><li class="src short"><a href="#v:aiturn">aiturn</a> :: <a href="Board.html#t:World">World</a> -&gt; <a href="Board.html#t:World">World</a></li><li class="src short"><a href="#v:besideFilledCells">besideFilledCells</a> :: <a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Col">Col</a> -&gt; [<a href="Board.html#t:Position">Position</a>]</li><li class="src short"><a href="#v:isBesideFilledCell">isBesideFilledCell</a> :: <a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Position">Position</a> -&gt; Bool</li><li class="src short"><a href="#v:emptyCells">emptyCells</a> :: <a href="Board.html#t:Board">Board</a> -&gt; [<a href="Board.html#t:Position">Position</a>]</li><li class="src short"><a href="#v:isEmptyCell">isEmptyCell</a> :: <a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Position">Position</a> -&gt; Bool</li><li class="src short"><a href="#v:emptyNeighbors">emptyNeighbors</a> :: <a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Position">Position</a> -&gt; [<a href="Board.html#t:Position">Position</a>]</li><li class="src short"><a href="#v:neighbors">neighbors</a> :: <a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Position">Position</a> -&gt; [<a href="Board.html#t:Position">Position</a>]</li><li class="src short"><a href="#v:removeDuplicates">removeDuplicates</a> :: [<a href="Board.html#t:Position">Position</a>] -&gt; [<a href="Board.html#t:Position">Position</a>]</li><li class="src short"><a href="#v:hint">hint</a> :: <a href="Board.html#t:World">World</a> -&gt; <a href="Board.html#t:World">World</a></li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:GameTree" class="def">GameTree</a></p><div class="doc"><p>The game tree consisting of the board, the current turn and a list of
    possible moves and the resulting sub-gametree. </p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:GameTree" class="def">GameTree</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:game_board" class="def">game_board</a> :: <a href="Board.html#t:Board">Board</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:game_turn" class="def">game_turn</a> :: <a href="Board.html#t:Col">Col</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:next_moves" class="def">next_moves</a> :: [(<a href="Board.html#t:Position">Position</a>, <a href="AI.html#t:GameTree">GameTree</a>)]</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><a name="v:buildTree" class="def">buildTree</a> :: (<a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Col">Col</a> -&gt; [<a href="Board.html#t:Position">Position</a>]) -&gt; <a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Col">Col</a> -&gt; <a href="AI.html#t:GameTree">GameTree</a></p><div class="doc"><p>A function to generate moves (i.e. board positions) for a player (Col)
    on a particular board, resulting in a (potentially) infinite game tree.
    Makes calls to the move generator to construct the tree of positions.
    relies on lazy evaluation to not construct more nodes than necessary.
    This means that even though the tree is huge,
    only the nodes accessed get created. </p></div></div><div class="top"><p class="src"><a name="v:getBestMove" class="def">getBestMove</a> :: Int -&gt; <a href="AI.html#t:GameTree">GameTree</a> -&gt; <a href="Board.html#t:Col">Col</a> -&gt; <a href="Board.html#t:Position">Position</a></p><div class="doc"><p>Get the best next move from a (possibly infinite) game tree. This
     traverses the game tree up to a certain depth, and pick the move which
     leads to the position with the best score for the player whose turn it
     is at the top of the game tree. </p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Selector" class="def">Selector</a> = [(Int, <a href="Board.html#t:Position">Position</a>)] -&gt; (Int, <a href="Board.html#t:Position">Position</a>)</p><div class="doc"><p>Selector type selects a value-move tuple from a list of such tuples.</p></div></div><div class="top"><p class="src"><a name="v:recurse" class="def">recurse</a> :: Int -&gt; <a href="AI.html#t:Selector">Selector</a> -&gt; <a href="AI.html#t:GameTree">GameTree</a> -&gt; <a href="Board.html#t:Col">Col</a> -&gt; (Int, <a href="Board.html#t:Position">Position</a>)</p><div class="doc"><p>A helper function for finding the best move. Returns a value-move tuple.
     This recursion goes down the game tree nodes, using the Selector to make predictions about
     the moves that will be taken. This function changes its selector every time it calls itself.
     This reflects the presumption that the AI will select the best move and the human player -
     the worst move (one that puts the AI in the worst position). </p></div></div><div class="top"><p class="src"><a name="v:switchSelector" class="def">switchSelector</a> :: <a href="AI.html#t:Selector">Selector</a> -&gt; <a href="AI.html#t:Selector">Selector</a></p><div class="doc"><p>Function swaps the selectors best and worst as every level in the gametree
     will need a different selector (my best move vs opponents worst move) </p></div></div><div class="top"><p class="src"><a name="v:best" class="def">best</a> :: <a href="AI.html#t:Selector">Selector</a></p><div class="doc"><p>Selector selects the best move from a list of moves and corresponding values.</p></div></div><div class="top"><p class="src"><a name="v:worst" class="def">worst</a> :: <a href="AI.html#t:Selector">Selector</a></p><div class="doc"><p>Selector selects the worst move from a list of moves and corresponding values.</p></div></div><div class="top"><p class="src"><a name="v:greater" class="def">greater</a> :: (Int, <a href="Board.html#t:Position">Position</a>) -&gt; (Int, <a href="Board.html#t:Position">Position</a>) -&gt; (Int, <a href="Board.html#t:Position">Position</a>)</p><div class="doc"><p>Comparator for value-move touples. Returns the <code><a href="AI.html#v:greater">greater</a></code> move.</p></div></div><div class="top"><p class="src"><a name="v:lesser" class="def">lesser</a> :: (Int, <a href="Board.html#t:Position">Position</a>) -&gt; (Int, <a href="Board.html#t:Position">Position</a>) -&gt; (Int, <a href="Board.html#t:Position">Position</a>)</p><div class="doc"><p>Comparator for value-move touples. Returns the <code><a href="AI.html#v:lesser">lesser</a></code> move.</p></div></div><div class="top"><p class="src"><a name="v:aiturn" class="def">aiturn</a> :: <a href="Board.html#t:World">World</a> -&gt; <a href="Board.html#t:World">World</a></p><div class="doc"><p>The AI makes a move by calling getBestMove to determine where to put a piece.</p></div></div><div class="top"><p class="src"><a name="v:besideFilledCells" class="def">besideFilledCells</a> :: <a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Col">Col</a> -&gt; [<a href="Board.html#t:Position">Position</a>]</p><div class="doc"><p>Given a board will return a list of empty cells beside filled cells</p></div></div><div class="top"><p class="src"><a name="v:isBesideFilledCell" class="def">isBesideFilledCell</a> :: <a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Position">Position</a> -&gt; Bool</p><div class="doc"><p>Function checks if a given cell is beside a filled cell</p></div></div><div class="top"><p class="src"><a name="v:emptyCells" class="def">emptyCells</a> :: <a href="Board.html#t:Board">Board</a> -&gt; [<a href="Board.html#t:Position">Position</a>]</p><div class="doc"><p>Given a board, this function will return list of positions that are empty
     This is very slow for large boards. Also this generator of moves is the last
     if the &quot;besideFilledCells&quot; generator fails. </p></div></div><div class="top"><p class="src"><a name="v:isEmptyCell" class="def">isEmptyCell</a> :: <a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Position">Position</a> -&gt; Bool</p><div class="doc"><p>Given a board and position, function will check if given position is empty</p></div></div><div class="top"><p class="src"><a name="v:emptyNeighbors" class="def">emptyNeighbors</a> :: <a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Position">Position</a> -&gt; [<a href="Board.html#t:Position">Position</a>]</p><div class="doc"><p>Given a board and position, function will return a list of empty neighbor cells</p></div></div><div class="top"><p class="src"><a name="v:neighbors" class="def">neighbors</a> :: <a href="Board.html#t:Board">Board</a> -&gt; <a href="Board.html#t:Position">Position</a> -&gt; [<a href="Board.html#t:Position">Position</a>]</p><div class="doc"><p>Function will return all neighbors to a cell (takes care of cells on the edge)</p></div></div><div class="top"><p class="src"><a name="v:removeDuplicates" class="def">removeDuplicates</a> :: [<a href="Board.html#t:Position">Position</a>] -&gt; [<a href="Board.html#t:Position">Position</a>]</p><div class="doc"><p>Function removes duplicates from a list of positions</p></div></div><div class="top"><p class="src"><a name="v:hint" class="def">hint</a> :: <a href="Board.html#t:World">World</a> -&gt; <a href="Board.html#t:World">World</a></p><div class="doc"><p>Displays a hint based on the ai algorithm in the console for the user. </p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>